h1. 11 Пути и указатели

h2. 11.1 Обзор

Архитектура openEHR содержит в себе механизм путей, который позволяет указывать на любой узел относительно структур верхнего уровня, используя "семантический" путь (т.е. используя архетипы), совместимый с X-path. Наличие такого пути координально меняет возможности для запросов медицинской информации, и является одной из основных отличительных особенностей openEHR.

В техническом отношении комбинация пути и идентификатора версии, т.е. @OBJECT_VERSION_ID@, формирует "глобальную уникальную ссылку на узел", который может быть выражен с помощью @LOCATABLE_REF@. Он так же может быть представлен в форме переносимого @URI@, используя @DV_EHR_URI@, и формирует "глобальный уникальный указатель узла". Такое представление позволяет сослаться откуда угодно на любой узел данных в openEHR. Данная секция описывает синтаксис и сематнику путей и ссылок в виде URI. В дальнейшем термин "путь архетипа" означает путь взятый из архетипа, в то время как "путь к данным" идентифицирует элемент в данных. Формально они не отличаются, эти термины используются только для указания на место использования.

h2. 11.2 Пути

h3. 11.2.1 Базовый синтаксис

Пути в openEHR используют синтаксис, совместимый с Xpath[1], который является супермножеством для синтаксиса путей, описанного в языке описания архетипов (Archetype Definition Language, ADL). Синтаксис спроектирован так, что бы он мог легко отображаться в Xpath, для целей использования в XML на базе openEHR.

Синтаксис путей к данным для выражения указателей использует общий шаблон путей, состоящий из сегментов - имен атрибутов[2], разделенных символом '/':

@attribute_name / attribute_name / ... / attribute_name@

Путь указывает на объект, соответствующий последнему атрибуту в пути, если идти по именам атрибутов от точки начала в дереве объектов. Точка начала указывает на стартовую часть в пути, и может быть задана двумя способами:

p. __относительный путь__: путь начинающийся с имени атрибута в текущей точки дерева (определенной в предыдущей операции или заданной рамками);

p. __абсолютный путь__: путь начинающийся с '/'; стартовая точка в структуре верхнего уровня.

Дополнительно, можно использовать нотацию "//" из Xpath для описания паттерна пути:

p. __шаблонный путь__: путь, начинающийся или содержащий символ '//', может быть сопоставлен с любым количеством сегментов данных; шаблон срабатывает, если актуальный путь совпадает с частью до символа '//', и секции далее совпадут с частью после '//'.

fn1. См. спецификацию W3C Xpath 1.0, 1999, "http://www.w3.org/TR/xpath":http://www.w3.org/TR/xpath.

fn2. В документации openEHR, термин "атрибут" употребляется в объектно-ориентированном значении как "свойство объекта", а не как понятие из XML -  именнованное значени в тегах. Синтаксис, описываемый в данном разделе, не должен рассматриваться в качестве обязательного для буквального отображения в XML сущности, а, скорее, он имеет логическое отоборажение в объектно-ориентированные структуры данных.

h3. 11.2.2 Предикаты

**Обзор**
Пути, описанные только с помощью имен атрибутов, ограничены с двух сторон. Во-первых, они могут указывать только на объекты в структурах, не содержащих контейнеры: списки (lists) или множества уникальных элементов (sets). В реальных данных, включая значительную часть данных openEHR, широко распространнены струкрутры: списки, уникальные множества и хеши. Необходим дополнительный синтаксис для сопоставления определенного объекта среди всех объектов из атрибута контейнера. Он представлен в виде выражений предикатов (predicate expression) заключенных в скобки ('[]') после атрибута в сегменте:

@attribute_name [predicate expression]@

В общем виде путь представлен следующим образом:

@attribute_name / attribute_name [predicate expression] / ...@

Предикат используется опционально для атрибутов типа контейнер в базовой модели (т.е. для которых мощность > 1). Если выражение предиката не используется с атрибутом типа контейнера, то выбирается целиком контейнер. Обратите внимаение, что предикат может быть использован с атрибутами, имеющими одно значение. В случае когда программное обсепечение для обработки обобщенных путей, не может определить разницу, технически предикат использоваться с одниночными атрибутами, но это не обязательное требование.

Второе ограничение простых путей состоит в том, что они не могут указать на объекты, на основе других условий, например, если объект имеет дочерний узел с определенным значением. Для решения этой проблемы, выражение предиката для выбора объекта может включать в себя условия, относительно объекта, такие как булевые выражения с путями, операторами, значениями и скобками. Синтаксис выражений предикатов в openEHR - это подмножество синтаксиса Xpath для предикатов с небольшим набором сокращений.

**Предикат пути архетипа**
Наиболее важный предикат использует значение __archetype_node_id__ (наследуемое из @LOCATABLE@) для ограничение элементов, возвращаемых из контейнера, например определенный @ELEMENT@ в @CLUSTER@. Сокращенная форма позволяет включить код архетипа как предикат, например, @[at0003]@. Такое сокращение использует пути архетипа для обращения к данным во время исполнения. Путь из архетипа, на примере экземпляра Наблюдения (Observation):

@/data/events[at0003]/data/items[at0025]/value/magnitude@

Этот путь указывает на величину общей оценки по шкале Апгар на 1ую минуту в Наблюдении (Observation), содержащей структуру полного результата Апгар. Здесь предикат @[atNNNN]@ является сокращением для ==<code>[@archetype_node_id = 'atNNNN']</code>== в стандарте Xpath. Хотя пути архетипа всегда уникальные, путь в примере может соответствовать более чем одному элементу данных во время исполнения, так как узлы, соответствующие одному узлу архетипа, могут повторно использоваться в контейнере.

**Предикаты с именами**
Для того, что бы гарантировать уникальность пути к данным, предикат так же может включать значение __name__ (также наследуемое из @LOCATABLE@), так же как и значение __archetype_node_id__. В форме Xpath пример выше будет выражен как:

@/data/events[at0001 and name/value='standing']@

Так как комбинация идентификатора узла архетипа и значения имени достаточно распространненая конструкция в базах данных на основе архетипов, используется сокращение для выражения __name/value__, которое просто включает значение после запятой:

@/data/events[at0001, 'standing']@

**Другие предикаты**
Можно использовать предикаты, на основе значений других атрибутов, например ELEMENT@.__name__ или @EVENT@.__time__. Часто используется в запросах кобминация __archetype_node_id__ и таких атрибутов (в примере экземпляр @OBSERVATION@):

@/data/events[at0007 AND time >= "24-06-2005 09:30:00"]@

Данный путь выберет события (Events) в Observation.data, у которых значение __archetype_node_id__ будет "summary event" (at0007 в этом архетипе) и которые произошли после данного времени. Следующий пример выберет Оценку (Evaluation) содержащую диагноз (at0002.1) "другие бактериальные кишечные инфекции" (Код A04 в МКБ-10):

bc.   /data/items[at0002.1
    AND value/defining_code/terminology_id/value = "ICD10AM"
    AND value/defining_code/code_string = "A04"]

h3. 11.2.3 Пути в структурах верхнего уровня

Пути в структурах верхнего уровня строго придерживаются имен атрибутов и функций в соответствующих частях базовой модели. Для различия соседних узлов в разных точках  структуры пути используется выражения предикаты, а особенно в точках "соединения" архетипов. В таких точках один архетип соединяется с другим, как показано на рисунке 30. Точки соедения в композиции (Composition) будут расположены между структурами Composition и Section, и возможно между структурой Section и другими вложенными Section (определенными на основе других архетипов Section), а так же между структурами Compositions/Section и Entries. Соединения так же могут быть внутри Entry, если архетипизация используется для структур нижнего уровня, таких как Item_lists и др. Большинство точек соединений лежит в контейнерах типа @List<T>@ и др. Например, @COMPOSITION@.__content__ определен как @List<CONTENT_ITEM>@, что означает реальное содержимое Composition будет списком структур Section. Для различия между соседними структурами используется предикат  __archetype_id__. В корневой точке архетипа в структуре данных (например, вверху структуры Section) __archetype_id__ содержит идентификатор архетипа, использованный для создания этой структуры данных, по тому же правилу, когда промежуточные точки в структуре архетипа соответствовали атрибуту __archetype_node_id__ и содержали значение __node_id__. Точки соединения между Section and Entrу работают по тем же правилам, так как может быть множество Entrу
 в одной Section, используется предикат archetype_id для того, что бы отличать их. Сокращение для предиката __archetype_id__ такое же как и для выражения предиката __archetype_node_ids__, например, ==<code>[@archetype_id = "xxxxx"]</code>== можно заменить @[xxxx]@.

Примеры путей, указывающие на элементы внутри Composition:

bc.   /content[openEHR-EHR-SECTION.vital_signs.v1 and name/value='Vital signs']/
    items[openEHR-EHR-OBSERVATION.heart_rate-pulse.v1 and name/value='Pulse']/
    data/events[at0003 and name/value='Any event']/data/items[at1005]
  /content[openEHR-EHR-SECTION.vital_signs.v1 and name/value='Vital signs']/
    items[openEHR-EHR-OBSERVATION.blood_pressure.v1 and
    name/value='Blood pressure']/data/events[at0006 and name/value='any event']/
    data/items[at0004]
  /content[openEHR-EHR-SECTION.vital_signs.v1, 'Vital signs']/
    items[openEHR-EHR-OBSERVATION.blood_pressure.v1, 'Blood pressure']/
    data/events[at0006, 'any event']/data/items[at0005]

Пути в других типах верхнего уровня следуют этому общему правилу, то есть  создаются последующими обязательными атрибутами в иерархии.

h3. 11.2.4 Пути к данным и уникальность

Пути архетипа не гарантируют уникальную идентификацию элементов данных, фактически потому что один узел архетипа может соответствовать множеству экземпляров данных. Но часто необходимо создать уникальный путь к реальному элементу данных. Это возможно с использованием атрибутов, отличающихся от __archetype_node_id__ в предикатах пути. Рассмотрим пример архетипа @OBSERVATION@:

bc. OBSERVATION[at0000] matches {  -- blood pressure measurement
    data matches {
      HISTORY matches {
        events {1..*} matches {
          EVENT[at0006] {0..1} matches {-- any event
            name matches {DV_TEXT matches {...}}
            data matches {
              ITEM_LIST[at0003] matches {-- systemic arterial BP
                count matches {2..*}
                items matches {
                  ELEMENT[at0004] matches {-- systolic BP
                    name matches {DV_TEXT matches {...}}
                    value matches {magnitude matches {...}}
                  }
                  ELEMENT[at0005] matches {-- diastolic BP
                    name matches {DV_TEXT matches {...}}
                    value matches {magnitude matches {...}}
                  }
                }
              }
            }
          }
        }
      }

Путь, взятый из архетипа, соответствует величине систолического давления крови:

@/data/events[at0006]/data/items[at0004]/value/magnitude@

Коды @[atnnnn]@ в каждом узле архетипа становятся __archetype_node_ids__, имеющимся в каждом узле данных 

Рассмотрим экземпляр @OBSERVATION@ (представленного в формате dADL), в котором записана история двух измерений кровяного давления:

bc. <  -- OBSERVATION - blood pressure measurement
    archetype_node_id = <[openEHR-EHR-OBSERVATION.blood_pressure.v1]>
    name = <value = <"BP measurement">>
    data = <                        -- HISTORY
      archetype_node_id = <[at0001]>
      origin = <2005-12-03T09:22:00>
      events = <                      -- List <EVENT>
          [1] = <                       -- EVENT
            archetype_node_id = <[at0006]>
            name = <value = <"sitting">>
            time = <2005-12-03T09:22:00>
            data = <                      -- ITEM_LIST
              archetype_node_id = <[at0003]>
              items = <                   -- List<ELEMENT>
                [1] = <
                  name = <value = <"systolic">>
                  archetype_node_id = <[at0004]>
                  value = <magnitude = <120.0> ...>
                >
                [2] = <....
                  name = <value = <"diastolic">>
                  archetype_node_id = <[at0005]>
                  value = <magnitude = <80.0> ...>
                >
              >
            >
          >
          [2] = <                       -- EVENT
            archetype_node_id = <[at0006]>
            name = <value = <"standing">>
            time = <2005-12-03T09:27:00>
            data = <                      -- ITEM_LIST
              archetype_node_id = <[at0003]>
              items = <                   -- List<ELEMENT>
                [1] = <
                  name = <value = <"systolic">>
                  archetype_node_id = <[at0004]>
                  value = <magnitude = <105.0> ...>
                >
                [2] = <
                  name = <value = <"diastolic">>
                  archetype_node_id = <[at0005]>
                  value = <magnitude = <70.0> ...>
                >
              >
            >
          >
        >
      >

[Примечание: в примере выше, имена значений (name values) показаны, как если бы они все были @DV_TEXTs@, в реальных данны в openEHR, они скорее всего были бы экземплярами @DV_CODED_TEXT@, как смоделировано в архетипе; причина в уменьшении размера примера, и нет разнеци в путях, приведенных ниже].

Пути архетипа, упомянутые выше представляют оба систолической давление в записи. В большинстве запросов, это то что ожидается. Для того что бы уникально сопоставить каждый узел систолического давления, необходимо что бы пути содержали не только __archetype_node_id__, но и другие атрибуты. В приведенном выше случае атрибут __name__  обеспечивает уникальность. Гарантированно уникальный пути для систолического и диастолического давлений в каждом измерении (сидя и стоя)
(идентичные выражения будут и в Xpath)[3]:

bc.   /data/events[1]/data/items[1]/value/magnitude
  /data/events[1]/data/items[2]/value/magnitude
  /data/events[2]/data/items[1]/value/magnitude
  /data/events[2]/data/items[2]/value/magnitude

fn3. нотация ==attr[1]== является сокращением для attr[position() = 1]

Более выразительные уникальные пути, на основе путей архетипа:

bc.   /data/events[at0006, 'sitting']/data/items[at0004]/value/magnitude
  /data/events[at0006, 'sitting']/data/items[at0005]/value/magnitude
  /data/events[at0006, 'standing']/data/items[at0004]/value/magnitude
  /data/events[at0006, 'standing']/data/items[at0005]/value/magnitude

Каждый из этих путей эквивалентен по форме выражению в Xpath:

bc.   /data/events[@archetype_node_id='at0006' and name/value='standing']
  /data/items[@archetype_node_id='at0004']
  /value/magnitude

Как правило, один или несколько значений атрибутов в данных во время исполнения могут однозначно идентифицировать любой узел данных в openEHR. Для облегчения создания уникальных путей, значение атрибута  __name__ (наследуемое от класса @LOCATABLE@) __обязательно__ должно быть уникальным в рамках соседних узлов. Из этого следует:
* гарантированно уникальный путь всегда может быть построен к любому элементу данных в openEHR, используя комбинацию значений __archetype_node_id__ и  __name__ (как показано выше в примере путей);
* значение __name__ можно систематически определяться как копия значений другого атрибута.

h2. 11.3 URIs в ЭМК

Есть две широкии категории URI, которые могут быть использованы с любыми ресурсами: прямые ссылки и запросы. Первый тип создается системами, содержащими элементы, на которые необходимо ссылаться, и которые передаются в другие системы. Второй тип - запросы из другой системы в форме URI.

h3. 11.3.1 Ссылочные URI в ЭМК

Для создания ссылок на узлы в ЭМК в форме URI (универсальные идентификатор ресурса), необходимы три элемента: путь __внутри__ структуры верхнего уровня, ссылка на структуры верхнего уровня внутри ЭМК, и ссылка на ЭМК. Все части вместе составляют URI в пространстве схемы "ehr", используя синтаксис:

@ehr:ehr_locator/top_level_structure_locator/path_inside_top_level_structure@

Таким образом, любой объект в любой ЭМК openEHR адресуется через URI. В пространстве ehr, ссытлки в стиле URL на определенные сервера, хосты и т.д. не используются из-за не надежности в долгосрочной перспективе. Вместо используются логические идентификаторы ЭМК и субъекта, позволяющие быть URI корректными на протежении всей жизни ресурса, на который они ссылаются. Тип данных @DV_EHR_URI@ спроектирован для хранения URI в этой форме, и позволяет создавать URI для использования внутри @LINKs@ или в других местах openEHR.

@ehr:@ URI предполагает наличие механизма разрешения имен в пространстве ehr, похожего на DNS, который обеспечивает работу http-, ftp- сервтовисов и других хорошо известных URI схем. Если такие сервисы не установлены, скорее всего будут использоваться свои собственные способы обработки URI на равне с более традиционным ссылками @http://@. Разделы ниже описывают как конструируются URI обоих типов.

**Расположение ЭМК**
В простренстве ehr, прямой указатель на ЭМК это идентификатор ЭМК, в отличии от идентификатора объекта, пациента или запроса. Обычно требуется только копия из 'локальной системы', и в большинстве времени будет только существовать только одна. В этом случае требуемая ЭМК может находится с помощью простых неквалифицированных идентификаторов, представленных в форме URI:

@ehr:1234567/@

В следствии копирования / синхронизации ЭМК для одного пациента среди множества систем ЭМК, данный идентификатор ЭМК может существовать в больше, чем одном месте. Не гарантируется, что каждая копия ЭМК полностью идентична другим, так как разрешено частичное копирование. Таким образом в средах, где существуют копии ЭМК, и есть необходимость находить точные экземпляры ЭМК, необхимо использовать идентификатор системы, представленных в форме URI:

bc. ehr:1234567@rmh.nhs.net/

**Указатель на структуры верхнего уровня**
Имеется два логических пути для иденификации структур верхнего уровня в ЭМК. Первый путь - использовать комбинацию иденификатора объекта верхнего уровня и версию во времени (например, системное время или время фиксации изменений). Для этого можно использовать однин из вариантов: uid соответствующего @VERSIONED_OBJECT@, или идентификатор архетипа или имя. В этом случае URI будут:

bc. ehr:1234567/87284370-2D4B-4e3d-A3F3-F303D2F4F34B@latest_trunk_version -- VO Guid
ehr:1234567/87284370-2D4B-4e3d-A3F3-F303D2F4F34B@2005-08-02T04:30:00 -- используя время

Второй путь - использовать точный идентификатор версии (openEHR Version identifier), который принимает форму @versioned_object_uid::creating_system_id::version_tree_id@. В этом случае URI будут:

@ehr:1234567/87284370-2D4B-4e3d-A3F3-F303D2F4F34B::rmh.nhs.net::2@

@ehr:1234567/87284370-2D4B-4e3d-A3F3-F303D2F4F34B::F7C5C7B7-75DB-
4b39-9A1E-C0BA9BFDBDEC::2@

Первый URI идентифицирует элемент верхнего уровня, чей идентификатор версии @87284370-2D4B-4e3d-A3F3-F303D2F4F34B::rmh.nhs.net::2@, или вторая версия в транке версий версионируемого объекта, идентифицируемого с помощью Guid, созданного системой ЭМК @net.nhs.rmh@. Второй URI такой же, но используется Guid для системы, создавшей объект. Обратите внимание, что упоминание системы в идентификаторе версий не означает, что запрашиваемая ЭМК находится в той системе, а означает только то, что данный объект верхнего уровня был создан в ней.

Если не указан идентификатор версии, всегда подразумевается 'latest_trunk_version':

@ehr:1234567/87284370-2D4B-4e3d-A3F3-F303D2F4F34B@

**URI для элементов**
С дополнением выражений для путей, как описано выше, URI могут ссылаться на самые мелкие элементы в ЭМК в openEHR:

bc.   ehr:1234567/87284370-2D4B-4e3d-A3F3-F303D2F4F34B@latest_trunk_version/
    content[openEHR-EHR-SECTION.vital_signs.v1]/
    items[openEHR-EHR-OBSERVATION.heart_rate-pulse.v1]/data/
    events[at0006, 'any event']/data/items[at0004]

**Относительные URI**
URI могут быть отностительными к текущей ЭМК, в случае когда нет id ЭМК:

bc.   ehr:87284370-2D4B-4e3d-A3F3-F303D2F4F34B@latest_version/
    content[openEHR-EHR-SECTION.vital_signs.v1]/
    items[openEHR-EHR-OBSERVATION.blood_pressure.v1]/
    data/events[at0006, 'any event']/data/items[at0004]

